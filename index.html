<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Export Vis</title>
<script language="javascript" type="text/javascript" src="js/jquery-1.5.2.js"></script>
<script language="javascript" type="text/javascript" src="js/exports.js"></script>
<script language="javascript" type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>
</head>
<body>
<p>Right click to set pivot point. Then click on a path.</p>
<script type="text/javascript">

$(document).ready(function() {
    var geocoder = new google.maps.Geocoder(),
        source = "New Zealand",
        data = {},
        locations,
        pivotPoint = null,
        debug = true;

    $exports.buildJSON(source, function(d) {
        data = d;
        build_geo_table(data);

        $.getJSON('public/nodesfile',function(loaded){
            data.nodes = loaded;

            var geocoder = new google.maps.Geocoder();
            
            geocoder.geocode({ address: source }, function(geo) {
                var opts = {
                  zoom: 8,
                  center: geo[0].geometry.location,
                  mapTypeId: google.maps.MapTypeId.ROADMAP
                }

                var map = new google.maps.Map(document.getElementById("map_canvas"), opts);
                var exports = data.exports.years['2010'];
                var totalExports = exports['(Total)'].exports;
                google.maps.event.addListener(map, 'rightclick', function(event){
                    // drop marker
                    pivotPoint = addMarker(map, event.latLng); 
                    
                });

                var multiP1,multiP2;
                google.maps.event.addListener(map, 'click', function(event){
                    if (multiP1 != null){
                        var multiP2 = event.latLng;
                        alert('multi point 2');

                        traverse_nodes(nodeOf(geo[0].geometry.location),null, data.nodes,function(n1,n2){
                            console.log(intersect(multiP1,multiP2,geoOfNode(n1),geoOfNode(n2)));
                            if (intersect(multiP1,multiP2,geoOfNode(n1),geoOfNode(n2))){
                                console.log(n2 + "  " + n1);
                                console.log(locations[n1]);
                            }

                        });

                    } else {
                        multiP1 = event.latLng;
                        alert('multi point 1');
                    }
                });

                //from source node.
                var sourceNode = nodeOf(geo[0].geometry.location);
                var topQueue = data.nodes[sourceNode];
                $.each(topQueue, function(index, value){
                    drawFromNode(value, sourceNode);
                });

                function drawFromNode(node,parent){
                    //returns the weight of what its done.
                    var queue = data.nodes[node];
                    var pathExports =0; //sum of value for weight.
                    if (node in locations) {
                        //draw
                        var name = locations[node];
                        pathExports = new Number(exports[name].exports);
                    } else {
                        $.each(queue, function(key,value){
                            if (value != parent){
                                console.log(key + " "+value);
                                pathExports += drawFromNode(value, node);
                            }
                        });
                    }

                    console.log('drawing '+parent+'=>'+node+"\t\t"+pathExports);

                    var exportPath = new google.maps.Polyline({
                        path: [geoOfNode(parent), geoOfNode(node)],
                        strokeColor: "#FF0000",
                        strokeOpacity: 1,
                        strokeWeight: 0.1 + (pathExports / totalExports) * 10,
                        map: map
                    });

                    // drop markers again
                    if (!locations[node]) {
                        addMarker(map, geoOfNode(node));
                    }

                     google.maps.event.addListener(exportPath, 'click', function(event){
                          if (pivotPoint!=null){
                              var path = exportPath.getPath();
                              var n1 = nodeOf(path.getArray()[0]);
                              var n2 = nodeOf(path.getArray()[1]);
                              //todo update node structure.
                              //todo handle merges.
                              
                              var pn = nodeOf(pivotPoint.getPosition());

                              var node2 = data.nodes[n2];
                              var node1 = data.nodes[n1];

                              var idx = node1.indexOf(n2);
                              node1.splice(idx,1);
                              node1.push(pn);

                              idx = node2.indexOf(n1);
                              node2.splice(idx,1);
                              node2.push(pn);

                              data.nodes[pn] = [n1,n2];
                          }
                     });
                    return pathExports;
                  }
            });
        });
        
    });

    function addMarker(map, latlng) {
        var m = new google.maps.Marker({
            position: latlng, 
            map: map,
            animation: google.maps.Animation.DROP,
            title: 'pivot'
        });
        
        m.setVisible(debug);
        
        google.maps.event.addListener(m, 'click', function(){
            if (m.getAnimation() != null) {
                m.setAnimation(null);
            } else {
                m.setAnimation(google.maps.Animation.BOUNCE);
                setTimeout(function() {
                    m.setAnimation(null);
                }, 1000);
            }
        });

        return m;
    }

    function nodeOf(object){
        //this accuracy might be bad.

        if (typeof(object.lat) != "function" & typeof(object.lng) != "function"){
            return object.lat+"|"+object.lng;
        }
        return ""+object.lat()+"|"+object.lng();
    }

    function geoOfNode(node){
        var latLng = node.split("|");
        return new google.maps.LatLng(parseFloat(latLng[0]), parseFloat(latLng[1]));
    }

    function build_geo_table(data){
        locations = {};
        for (g in data.geo){
            locations[nodeOf(data.geo[g])] = g;
        }
    }

    function traverse_nodes(node, parent, nodes, callback){
        var queue = data.nodes[node];
        if (parent != null) {callback(node,parent);}
        $.each(queue, function (key,value){
            if (value != parent){
                traverse_nodes(value,node,nodes,callback);
            }
        });
    }

    function intersect(p1,p2,p3,p4){
        // why cant i find a library with this !!!!
        // http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=geometry2
        //does line p1-p2 intersect p3-p4

        //Shit, the coordinates in the map wrap backward and stuff.,,, na surely this will work
        
        //lat is Y, lng is X

        var x1 = p1.lng();
        var y1 = p1.lat();
        var x2 = p2.lng();
        var y2 = p2.lat();
        var x3 = p3.lng();
        var y3 = p3.lat();
        var x4 = p4.lng();
        var y4 = p4.lat();

        var A1 = y2-y1;
        var B1 = x1-x2;
        var C1 = (A1*x1) + (B1*y1);

        var A2 = y4-y3;
        var B2 = x3-x4;
        var C2 = (A2*x3) + (B2*y3);

        var det = (A1*B2) - (A2*B1);
        
        if (det==0){
            //lines are parallel.
            return false; // could be same line
        } else {
            var x = (B2*C1 - B1*C2) / det;
            var y = (A1*C2 - A2*C1) / det;

            var minX = Math.min(x1,x2);
            var maxX = Math.max(x1,x2);
            var minY = Math.min(y1,y2);
            var maxY = Math.max(y1,y2);
                        
            if (minX <= x && x <= maxX && minY<= y && y<= maxY){
                minX = Math.min(x3,x4);
                maxX = Math.max(x3,x4);
                minY = Math.min(y3,y4);
                maxY = Math.max(y3,y4);
                
                if (minX <= x && x <= maxX && minY<= y && y<= maxY){
                    return true;
                }
            }   
        }
        return false;
    } 


    function save(){
        var s_save = data.nodes;
        $.post('php/save.php?filename=nodesfile', {nodes: data.nodes });
        alert('save');
    }

    // add handler to debug button
    $('#btnDebug').click(function() {
    });

    // add handler to save button
    $('#btnSave').click(function() {
        save();
    });
});

</script>
<div id="map_canvas" style="height:600px;width:1000px"></div> 
<input id="btnSave" type="button" value="save" />
<input id="btnDebug" type="button" value="debug" />
</body>
</html>
